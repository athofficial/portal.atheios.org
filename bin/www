#!/usr/bin/env node

/**
 * Module dependencies.
 */

'use strict';

// Prepare for logging
const fs = require('fs');
const path = require('path');
const filename = path.join(process.cwd()+'/Logs/', 'created-logfile.log');

//
// Remove the file, ignoring any errors
//
try { fs.unlinkSync(filename); }
catch (ex) { }

var logger = require("../logger");
logger.info("Logging initiated");

const bcrypt = require('bcryptjs');


global.config = require("../config")();

var ath = require('../ath');
var app = require('../app');
var debug = require('debug')('portal:server');
var http = require('http');
var WebSocket = require('ws');
var CryptoJS = require("crypto-js");


const {MISC_makeid, MISC_maketoken} = require('../misc');



/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(global.config.PORT || '3002');
app.set('port', port);
logger.info("Server started: " + global.config.httphost);



/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

const wss = new WebSocket.Server({ port: 3003 });

wss.on('connection', (ws, req) => {
  // Let us check first if the request comes from a valid game id
  logger.info("On connection: %s, %s",req.url, req.headers);
  var urlarray = req.url.split('/');
  // urlarray[1] is 'ws'
  // urlarray[2] is gameid
  if (urlarray[1]==="ws") {
    // initial access which we redirect to another server
    logger.info("Initial access.");
    if (config.development) {
      var jstring="{\"@class\":\".AuthenticatedConnectRequest\", \"connectUrl\":\"wss://localhost:3003/fs/"+ urlarray[2] +"\", \"requestId\":\"0\"}";
    }
    else {
      var jstring="{\"@class\":\".AuthenticatedConnectRequest\", \"connectUrl\":\"wss://portal.atheios.org:3003/fs/"+ urlarray[2] +"\", \"requestId\":\"0\"}";
    };

    ws.send(jstring);
  } else {
    if (urlarray[1] === "fs") {
      // Redirected access
      logger.info("Redirected access.");
      var sql = "SELECT * FROM gameasset WHERE asset_token=" + pool.escape(urlarray[2]) + " AND asset_ready=2";
      pool.query(sql, function (error, rows, fields) {
        if (error) {
          logger.error("%s", error);
          throw(error);
        } else {
          if (rows.length == 1) {
            logger.info("Game exists");
            // Gane exists and is published
            //  const ip = ws.headers['x-forwarded-for'].split(/\s*,\s*/)[0];
            logger.info("Connection established.");
            // okay we received a connect. This connect is taregtedd to the main server. In order to offload we could request to connect to a different server
            // For that reason we will send back the config data for connection. We potentially could offload to different geografical reasons based on IP
            // generate a nonce
            var randstr = MISC_maketoken(5);
            jstring = "{\"@class\":\".AuthenticatedConnectResponse\", \"nonce\":\"" + randstr + "\", \"requestId\":\"0\"}";
            ws.send(jstring);

            ws.on('message', function incoming(message) {
              logger.info('received: %s', message);
              // Here we handle the different incoming items
              if (message === " ") {
                logger.info("Keep alive");
              } else {

                try {
                  var result = JSON.parse(message);
                } catch (e) {
                  logger.error('An error ocurred while parsing the JSON Data: ' + message + '; Error: ' + e);
                  return;
                }

                var resultType = result['@class'];

                switch(resultType) {
                  case '.AuthenticatedConnectRequest':
                    func_AuthenticatedConnectRequest(ws, randstr, rows, result);
                    break;
                  case '.AuthenticationRequest':
                    func_AuthenticationRequest(ws, randstr, rows, result);
                    break;
                  case '.AccountDetailsRequest':
                    func_AccountDetailsRequest(ws, randstr, rows, result);
                    break;
                  case '.SetWageRequest':
                    func_SetWageRequest(ws, randstr, rows, result);
                    break;
                  case '.FinishGameRequest':
                    func_FinishGameRequest(ws, randstr, rows, result);
                    break;
                  case '.GameLadderRequest':
                    func_GameLadderRequest(ws, randstr, rows, result);
                    break;
                }

              }
            });
          } else {
            // Game ID cannot be found
            logger.warn("GameID cannot be found:", urlarray[2]);
            // TODO Maybe we need to find a solution that the  with a wrong Game ID we are not getting repeated attempts
            ws.close(1011, "ERR: game secrete not correct");
          }
        }
      });
    } else {
      // strange access
      ws.close();
    }
  }

});







/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}

function func_AuthenticatedConnectRequest(ws, randstr, rows, result) {
  var jstring;

  logger.info("Found AuthenticatedConnectRequest")
  var hmac = result['hmac'];
  var ownhmac = CryptoJS.enc.Base64.stringify(CryptoJS.HmacSHA256(randstr, rows[0].asset_secret));
  if (hmac === ownhmac) {
    jstring = "{\"@class\":\".AuthenticatedConnectResponse\", \"requestId\":\"0\", \"sessionId\":\"" + randstr + "\"}";
    ws.send(jstring);
  } else {
    // Game ID cannot be found
    logger.warn("GameID + secret cannot be matched: %s", urlarray[2]);
    // TODO Maybe we need to find a solution that the  with a wrong password we are not getting repeated attempts
    ws.close(1006, "ERR: game secrete not correct");
  }
}

function func_AuthenticationRequest(ws, randstr, rows, result) {
  var jstring;

  logger.info("Found AuthenticationRequest\n%s", result);
  var username = result['username'];
  var userpass = result['userpass'];

  var sql = "SELECT * FROM user WHERE username LIKE " + pool.escape(username);
  if (debugon)
    logger.info(sql);
  pool.query(sql, function (error, rows, fields) {
    if (error) {
      logger.error("%s", error);
      throw(error);
    } else {
      bcrypt.compare(userpass, rows[0].password).then(function (res) {
        // res == true
        if (res == true) {

          if (debugon)
            logger.info("User exists");
          var randstr = MISC_makeid(24);

          jstring = "{\n" +
              "  \"@class\" : \".AuthenticationResponse\",\n" +
              "  \"authToken\" : \"" + randstr + "\",\n" +
              "  \"displayName\" : \"" + rows[0].displayname + "\",\n" +
              "  \"newPlayer\" : false,\n" +
              "  \"userId\" : \"" + rows[0].id + "\",\n" +
              "  \"requestId\" : \"" + result['requestId'] + "\"\n" +
              "}";
          ws.send(jstring);
          // Update the entry with the authtoken
          var vsql = "UPDATE user SET authtoken=" + pool.escape(randstr) + " WHERE id=" + rows[0].id;
          pool.query(vsql, function (error, rows1, fields) {
            if (error) {
              if (debugon)
                logger.error('Error: %s', error);
              throw error;
            }
          });

        } else {
          logger.warn("User doesn't exist");
          jstring = "{\n" +
              "  \"@class\":\".AuthenticationResponse\"," +
              "  \"error\":{\"DETAILS\":\"UNRECOGNISED\"}," +
              "  \"newPlayer\":false," +
              "  \"requestId\" : \"" + result['requestId'] + "\"\n" +
              "}";
          ws.send(jstring);

          // There is a problem
          // Deny authentication
        }

      });
    }
  });
}

function func_AccountDetailsRequest(ws, randstr, rows, result) {
  var jstring;
  var authtoken=result['authToken'];

  logger.info("Found AccountDetailRequest\n%s", result);
  var vsql = "SELECT * FROM user WHERE authtoken=" + pool.escape(authtoken);
  logger.info("SQL: %s", vsql);
  pool.query(vsql, function (error, rows, fields) {
    if (error) {
      if (debugon)
        logger.error('Error: %s', error);
      throw error;
    }
    if (rows.length == 1) {
      logger.info("Authenticated");
      jstring = "{\n" +
          "  \"@class\" : \".AccountDetailsResponse\",\n" +
          "  \"value\" : " + rows[0].athamount + ",\n" +
          "  \"currency\" : \"ATH\",\n" +
          "  \"requestId\" : \"" + result['requestId'] + "\"\n" +
          "}";
      ws.send(jstring);
    }
  });
}

function func_SetWageRequest(ws, randstr, rows, result) {
  var jstring;

  var authtoken=result['authToken'];

  logger.info("Found SetWageRequest\n%s", result);
  var vsql = "SELECT * FROM user WHERE authtoken=" + pool.escape(authtoken);
  pool.query(vsql, function (error, rows, fields) {
    if (error) {
      if (debugon)
        logger.error('Error: %s', error);
      throw error;
    }
    if (rows.length == 1) {
      // OK we identified the connection
      logger.info("Authenticated");
      var wage = parseInt(result['wage']);
      var amount = rows[0].athamount - parseInt(pool.escape(result['wage']));
      if (!(amount > 0)) {
        // Wage amount is not correct
        jstring = "{\n" +
            "  \"@class\" : \".SetWageResponse\",\n" +
            "  \"authToken\" : \"" + result['authToken'] + "\",\n" +
            "  \"value\" : " + rows[0].athamount + ",\n" +
            "  \"playid\" : \"0\",\n" +
            "  \"currency\" : \"ATH\",\n" +
            "  \"status\" : \"NOK\",\n" +
            "  \"reason\" : \"You do not have so many coins available.\",\n" +
            "  \"requestId\" : \"" + result['requestId'] + "\"\n" +
            "}";
        ws.send(jstring);

      } else {
        // Register wage for this user and this game
        // Set game as started
        var vsql = "SELECT * FROM gameasset WHERE asset_token=" + pool.escape(result['apiKey']);
        logger.info("SQL: %s", vsql);
        pool.query(vsql, function (error, rows1, fields) {
          if (error) {
            if (debugon)
              logger.error('Error: %s', error);
            throw error;
          }

          if (rows1.length == 1) {
            // Game is available register the wage and gameplay
            vsql = "UPDATE user SET athamount=" + amount + " WHERE id=" + rows[0].id;
            logger.info("SQL: %s", vsql);
            pool.query(vsql, function (error, rows2, fields) {
              if (error) {
                if (debugon)
                  logger.error('Error: %s', error);
                throw error;
              }
              var wsql = "INSERT INTO gameplay (userid, gameasset_id, amount, gameplay_start_date, gameplay_options, authtoken) VALUES (" + rows[0].id + "," + rows1[0].id + "," + wage + ",'" + pool.mysqlNow() + "', 1, " + pool.escape(authtoken) + ")";
              logger.info("SQL: %s", wsql);
              pool.query(wsql, function (error, rows3, fields) {
                if (error) {
                  if (debugon)
                    logger.error('Error: %s', error);
                  throw error;
                }
                logger.info("InsertId: %s", rows3.insertId);
                jstring = "{\n" +
                    "  \"@class\" : \".SetWageResponse\",\n" +
                    "  \"authToken\" : \"" + result['authToken'] + "\",\n" +
                    "  \"value\" : " + amount + ",\n" +
                    "  \"playid\" : " + rows3.insertId + ",\n" +
                    "  \"gameid\" : " + rows1[0].id + ",\n" +
                    "  \"currency\" : \"ATH\",\n" +
                    "  \"status\" : \"OK\",\n" +
                    "  \"reason\" : \"\",\n" +
                    "  \"requestId\" : \"" + result['requestId'] + "\"\n" +
                    "}";
                ws.send(jstring);

              });
            });
          } else {
            jstring = "{\n" +
                "  \"@class\" : \".SetWageResponse\",\n" +
                "  \"authToken\" : \"" + result['authToken'] + "\",\n" +
                "  \"value\" : " + rows[0].athamount + ",\n" +
                "  \"playid\" : \"0\",\n" +
                "  \"currency\" : \"ATH\",\n" +
                "  \"gameid\" : \"undefined\",\n" +
                "  \"status\" : \"NOK\",\n" +
                "  \"reason\" : \"Game doesn't exist anymore: \""+ rows1.length +",\n" +
                "  \"requestId\" : \"" + result['requestId'] + "\"\n" +
                "}";
            ws.send(jstring);
            logger.error("Couldn't find single game: %s", jstring);

          }
        });
      }
    }
  });
}

// Input
// ScoreValue
// gameID
// authToken
function func_FinishGameRequest(ws, randstr, rows, result) {
  var jstring;
  var playid=parseInt(result['playId']);
  var authtoken=result['authToken'];
  var score=parseInt(result['scoreValue']);

  var vsql = "UPDATE gameplay SET gameplay_score=" + pool.escape(score) + ", gameplay_end_date='" + pool.mysqlNow() + "', gameplay_options=2 WHERE id=" + pool.escape(playid) + " AND authtoken LIKE '" + pool.escape(authtoken)+ "'";
  logger.info("SQL: %s", vsql);
  pool.query(vsql, function (error, rows2, fields) {
    if (error) {
      if (debugon)
        logger.error('Error: %s', error);
      throw error;
    }

    logger.info("Found Finish game\n%s", result);
    jstring = "{\n" +
        "  \"@class\" : \".FinishGameResponse\",\n" +
        "  \"authToken\" : \"" + result['authToken'] + "\",\n" +
        "  \"status\" : \"OK\",\n" +
        "  \"reason\" : \"\",\n" +
        "  \"requestId\" : \"" + result['requestId'] + "\"\n" +
        "}";
    ws.send(jstring);
  });

}

// gameID
// authToken
// userId
function func_GameLadderRequest(ws, randstr, rows, result) {
  var jstring;
  var gameid=parseInt(result['gameId']);
  var userid=parseInt(result['userId']);

  logger.info("Found GameLadder\n%s", result);

  // First we find the latest game
  var sql = "SELECT * FROM gameplay WHERE gameplay_options=2 AND gameasset_id=" + pool.escape(gameid) + " AND userid=" + pool.escape(userid) + " ORDER BY gameplay_end_date DESC LiMIT 1";
  logger.info("SQL: %s", sql);
  pool.query(sql,function (error, rows2, fields) {
    if (error) {
      if (debugon)
        logger.error('Error: %s', error);
      throw error;
    }

    var sql = "SELECT *, DATE_FORMAT(gameplay_end_date,'%Y-%m-%d') AS date FROM gameplay WHERE gameplay_options=2 AND gameasset_id=" + pool.escape(gameid) + " ORDER BY gameplay_score DESC";
    logger.info("SQL: %s", sql);
    pool.query(sql, function (error, rows, fields) {
      if (error) {
        if (debugon)
          logger.error('Error: %s', error);
        throw error;
      }
      var vsql = "SELECT * FROM user WHERE id=" + userid + ";";
      logger.info("SQL: %s", vsql);
      pool.query(vsql, function (error, rows1, fields) {
        if (error) {
          if (debugon)
            logger.error('Error: %s', error);
          throw error;
        }

        var i,j;
        var nrofgames = rows.length;
        var ladder = "";
        // Now we search for the latest game
        for (j = 0; j < rows.length; j++) {
          logger.info("j: %s, Rows2: %s, rows: %s",j,rows2[0].id, rows[j].id);
          if (rows2[0].id===rows[j].id)
            break;
        }

        ladder += "{\n" +
          "  \"position\" : \"" + (j+1) + "\",\n" +
          "  \"score\" : \"" + rows[j].gameplay_score + "\",\n" +
          "  \"displayname\" : \"" + rows1[0].displayname + "\",\n" +
          "  \"date\" : \"" + rows[j].date + "\"\n" +
          "},";

        if (nrofgames < 5) {
          for (i = 0; i < rows.length; i++) {
            ladder += "{\n" +
                "  \"position\" : \"" + (i + 1) + "\",\n" +
                "  \"score\" : \"" + rows[i].gameplay_score + "\",\n" +
                "  \"displayname\" : \"" + rows1[0].displayname + "\",\n" +
                "  \"date\" : \"" + rows[i].date + "\"\n" +
                "},";
          }
        } else {
          for (i = 0; i < 5; i++) {
            ladder += "{\n" +
                "  \"position\" : \"" + (i+1) + "\",\n" +
                "  \"score\" : \"" + rows[i].gameplay_score + "\",\n" +
                "  \"displayname\" : \"" + rows1[0].displayname + "\",\n" +
                "  \"date\" : \"" + rows[i].date + "\"\n" +
                "},";
          }
          for (i = j; i < rows.length; i++) {
            if (rows[i].userid == result['userId']) {
              ladder += "{\n" +
                  "  \"position\" : \"" + (i+1) + "\",\n" +
                  "  \"score\" : \"" + rows[i].gameplay_score + "\",\n" +
                  "  \"displayname\" : \"" + rows1[0].displayname + "\",\n" +
                  "  \"date\" : \"" + rows[i].date + "\"\n" +
                  "},";
            }
          }
        }
        ladder = ladder.slice(0, -1);
        jstring = "{\n" +
            "  \"@class\" : \".GameLadderResponse\",\n" +
            "  \"authToken\" : \"" + result['authToken'] + "\",\n" +
            "  \"requestId\" : \"" + result['requestId'] + "\",\n" +
            "  \"totalGames\" : " + nrofgames + ",\n" +
            "  \"ladder\" : [\n" + ladder + "]\n" +
            "}";
        ws.send(jstring);
      });
    });
  });
};

